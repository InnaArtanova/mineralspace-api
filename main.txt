# main.py
from fastapi import FastAPI, Depends, HTTPException, status, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from uuid import UUID
from typing import List, Optional
from sqlalchemy import func, or_, and_
from fastapi.responses import JSONResponse

import schemas  # ← добавьте эту строку

from database import get_db
from models import User, Collection, Specimen, Comment, MineralReference, UserCredentials
from schemas import (
    UserRegisterRequest, UserLoginRequest, UserProfile, UserUpdateRequest,
    CollectionCreateRequest, CollectionUpdateRequest, Collection as CollectionSchema,
    SpecimenCreateRequest, SpecimenUpdateRequest, Specimen,
    CommentCreateRequest, Comment, MineralReference, Error
)
from schemas import Collection as CollectionSchema
from auth import (
    get_password_hash, verify_password, create_access_token,
    get_current_user, ACCESS_TOKEN_EXPIRE_MINUTES, timedelta
)

app = FastAPI(
    title="MineralSpace API",
    description="RESTful API для коллекционеров минералов.",
    version="1.0.0",
    contact={
        "name": "Инна Артанова",
        "email": "inna.artanova@example.com",
        "url": "https://linkedin.com/in/inna-artanova"
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT"
    }
)

bearer_scheme = HTTPBearer()

# CORS (настройте по необходимости)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# === AUTH ===
@aap.post("/collections", status_code=status.HTTP_201_CREATED, response_model=schemas.Collection, tags=["Collections"])
async def create_collection(
    collection_create: schemas.CollectionCreateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    new_collection = Collection(
        title=collection_create.title,
        description=collection_create.description,
        is_public=collection_create.is_public,
        owner_id=current_user.id  # ← Передаём ID владельца
    )
    db.add(new_collection)
    await db.commit()
    await db.refresh(new_collection)
    return new_collection  # ← Просто возвращаем объект — FastAPI сам сериализует
@app.post("/auth/login", tags=["Auth"])
async def login(login_data: UserLoginRequest, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User).options(selectinload(User.credentials)) 
    .where(User.email == login_data.email)
)
    
    user = result.scalar_one_or_none()
    if not user or not verify_password(login_data.password, user.credentials.password_hash):
        raise HTTPException(status_code=401, detail="Invalid email or password")
    access_token = create_access_token(data={"sub": str(user.id)})
    return {
        "user": UserProfile(
            id=user.id,
            name=user.name,
            avatar_url=user.avatar_url,
            bio=user.bio,
            created_at=user.created_at,
            updated_at=user.updated_at
        ),
        "accessToken": access_token
    }

# === USERS ===
@app.get("/me", response_model=UserProfile, tags=["Users"])
async def get_me(current_user: User = Depends(get_current_user)):
    return current_user

@app.patch("/me", response_model=UserProfile, tags=["Users"])
async def update_me(
    update_data: UserUpdateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    for field, value in update_data.dict(exclude_unset=True).items():
        setattr(current_user, field, value)
    await db.commit()
    await db.refresh(current_user)
    return current_user

@app.delete("/me", status_code=status.HTTP_204_NO_CONTENT, tags=["Users"])
async def delete_me(current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    await db.delete(current_user)
    await db.commit()
    return

# === COLLECTIONS ===
@app.get("/collections", response_model=List[CollectionSchema])
async def list_collections(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    offset = (page - 1) * limit
    stmt = (
        select(Collection)
        .where(Collection.owner_id == current_user.id)
        .offset(offset)
        .limit(limit)
    )
    result = await db.execute(stmt)
    collections = result.scalars().all()
    return collections

@app.post("/collections", status_code=status.HTTP_201_CREATED, response_model=CollectionSchema, tags=["Collections"])
async def create_collection(
    collection_create: CollectionCreateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    new_collection = Collection(
        title=collection_create.title,
        description=collection_create.description,
        is_public=collection_create.is_public,
        owner_id=current_user.id
    )
    db.add(new_collection)
    await db.commit()
    await db.refresh(new_collection)

    # Явно загружаем владельца
    result = await db.execute(
        select(Collection)
        .options(selectinload(Collection.owner))
        .where(Collection.id == new_collection.id)
    )
    collection_with_owner = result.scalar_one()

    # ВРУЧНУЮ создаём Pydantic-объект
    return CollectionSchema(
        id=collection_with_owner.id,
        title=collection_with_owner.title,
        description=collection_with_owner.description,
        is_public=collection_with_owner.is_public,
        owner_id=collection_with_owner.owner_id,
        created_at=collection_with_owner.created_at,
        updated_at=collection_with_owner.updated_at,
        # owner_name НЕЛЬЗЯ передать, если он есть в схеме — но лучше его убрать!
    )
# === SPECIMENTS ===
# GET /specimens — все образцы текущего пользователя
@app.get("/specimens", tags=["Specimens"])
async def list_user_specimens(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    offset = (page - 1) * limit
    stmt = (
        select(Specimen)
        .join(Collection, Specimen.collection_id == Collection.id)
        .where(Collection.owner_id == current_user.id)
        .offset(offset)
        .limit(limit)
    )
    result = await db.execute(stmt)
    items = result.scalars().all()
    total = await db.scalar(
        select(func.count())
        .select_from(Specimen)
        .join(Collection)
        .where(Collection.owner_id == current_user.id)
    )
    return {"items": items, "total": total, "page": page, "limit": limit}


# POST /collections/{collectionId}/specimens
@app.post(
    "/collections/{collection_id}/specimens",
    status_code=status.HTTP_201_CREATED,
    response_model=Specimen,
    tags=["Specimens"]
)
async def add_specimen_to_collection(
    collection_id: UUID,
    specimen_data: SpecimenCreateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    collection = await db.get(Collection, collection_id)
    if not collection:
        raise HTTPException(status_code=404, detail="Collection not found")
    if collection.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="You do not own this collection")

    specimen = Specimen(
        collection_id=collection_id,
        **specimen_data.dict(exclude_unset=True)
    )
    db.add(specimen)
    await db.commit()
    await db.refresh(specimen)
    return specimen


# GET /specimens/{id}
@app.get("/specimens/{specimen_id}", response_model=Specimen, tags=["Specimens"])
async def get_specimen(
    specimen_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    specimen = await db.get(Specimen, specimen_id)
    if not specimen:
        raise HTTPException(status_code=404, detail="Specimen not found")

    collection = await db.get(Collection, specimen.collection_id)
    if not collection.is_public and collection.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Access denied to private collection")

    # Опционально: подгрузить mineralData
    mineral_ref = None
    if specimen.mineral_id:
        mineral_ref = await db.get(MineralReference, specimen.mineral_id)

    return Specimen(
        id=specimen.id,
        collection_id=specimen.collection_id,
        mineral_id=specimen.mineral_id,
        local_name=specimen.local_name,
        region=specimen.region,
        location=specimen.location,
        photo_url=specimen.photo_url,
        found_at=specimen.found_at,
        created_at=specimen.created_at,
        updated_at=specimen.updated_at,
        mineral_data=mineral_ref
    )


# PATCH /specimens/{id}
@app.patch("/specimens/{specimen_id}", response_model=Specimen, tags=["Specimens"])
async def update_specimen(
    specimen_id: UUID,
    update_data: SpecimenUpdateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    specimen = await db.get(Specimen, specimen_id)
    if not specimen:
        raise HTTPException(status_code=404, detail="Specimen not found")

    collection = await db.get(Collection, specimen.collection_id)
    if collection.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="You cannot edit specimens in others' collections")

    for field, value in update_data.dict(exclude_unset=True).items():
        setattr(specimen, field, value)
    await db.commit()
    await db.refresh(specimen)

    mineral_ref = None
    if specimen.mineral_id:
        mineral_ref = await db.get(MineralReference, specimen.mineral_id)

    return Specimen(
        id=specimen.id,
        collection_id=specimen.collection_id,
        mineral_id=specimen.mineral_id,
        local_name=specimen.local_name,
        region=specimen.region,
        location=specimen.location,
        photo_url=specimen.photo_url,
        found_at=specimen.found_at,
        created_at=specimen.created_at,
        updated_at=specimen.updated_at,
        mineral_data=mineral_ref
    )


# DELETE /specimens/{id}
@app.delete("/specimens/{specimen_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Specimens"])
async def delete_specimen(
    specimen_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    specimen = await db.get(Specimen, specimen_id)
    if not specimen:
        raise HTTPException(status_code=404, detail="Specimen not found")

    collection = await db.get(Collection, specimen.collection_id)
    if collection.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="You cannot delete specimens in others' collections")

    await db.delete(specimen)
    await db.commit()
    return

# === COMMENTS ===

# POST /comments
@app.post("/comments", status_code=status.HTTP_201_CREATED, response_model=Comment, tags=["Comments"])
async def create_comment(
    comment_data: CommentCreateRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    specimen = await db.get(Specimen, comment_data.specimen_id)
    if not specimen:
        raise HTTPException(status_code=404, detail="Specimen not found")

    # Проверка доступа к образцу (через коллекцию)
    collection = await db.get(Collection, specimen.collection_id)
    if not collection.is_public and collection.owner_id != current_user.id:
        # Можно разрешить комментировать публичные коллекции даже не владельцам
        # Но если коллекция приватная — только владелец может видеть → комментировать нельзя
        pass  # В текущей логике: любой авторизованный пользователь может комментировать ЛЮБОЙ видимый образец
        # Но мы не знаем, видит ли он его. Для упрощения — разрешаем всем авторизованным.
        # Если нужно строже — проверяйте, как в get_specimen

    comment = Comment(
        specimen_id=comment_data.specimen_id,
        user_id=current_user.id,
        text=comment_data.text
    )
    db.add(comment)
    await db.commit()
    await db.refresh(comment)
    return comment


# DELETE /comments/{commentId}
@app.delete("/comments/{comment_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Comments"])
async def delete_comment(
    comment_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    comment = await db.get(Comment, comment_id)
    if not comment:
        raise HTTPException(status_code=404, detail="Comment not found")
    if comment.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="You can only delete your own comments")
    await db.delete(comment)
    await db.commit()
    return



# === REFERENCE DATA ===
@app.get("/reference/mineral-types", response_model=List[schemas.MineralType], tags=["Reference Data"])
async def get_mineral_types(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(schemas.MineralType))
    return result.scalars().all()

# Аналогично для /reference/hardness, /cleavages и др.

# === MINERALS ===
@app.get("/minerals/{mineral_id}", response_model=MineralReference, tags=["Minerals"])
async def get_mineral(mineral_id: str, db: AsyncSession = Depends(get_db)):
    mineral = await db.get(MineralReference, mineral_id)
    if not mineral:
        raise HTTPException(status_code=404, detail="Mineral not found")
    return mineral